.arm
.text
.global main
main:
STMDB R13!, {R0-R12,R14}
LDR R1, =Const @Θέτουμε τον R1 να δείχνει στις διευθύνσεις του 
πίνακα Const
LDR R2, =Result @Θέτουμε τον R2 να δείχνει στις διευθύνσεις του 
πίνακα Result
MOV R3, #0 @Μεταφέρουμε στον R3 τη τιμή 0 και τον χρησιμοποιούμε 
για να διαβάζουμε τα bytes στις διευθύνσεις των πινάκων
MOV R4, #0 @Μεταφέρουμε στον R4 τη τιμή 0 και τον χρησιμοποιούμε 
για να διαβάζουμε τα bytes στις διευθύνσεις των πινάκων
BL Subrtn @Καλούμε την υπορουτίνα 4 φορές για τον υπολογισμό των 
xi
BL Subrtn
BL Subrtn
BL Subrtn
LDMIA R13!, {R0-R12,R14} @Επανακτούμε το περιεχόμενο των 
καταχωρητών που είχαμε σώσει
MOV PC,LR @Επιστρέφουμε από την υπορουτίνα στο σημείο όπου 
κλήθηκε
Επανάληψη Αποτέλεσμα
1 00
2 05
3 FF
4 03
8
Subrtn:
STMDB R13!, {R0-R11,R14}
LDR R0, =Values @Θέτουμε τον R0 να δείχνει στις διευθύνσεις του 
πίνακα Values
ADD R0,R0,R4
MOV R5, #5 @Μεταφέρουμε στον R5 τη τιμή 5
LDRB R6, [R0,#0] @Μεταφέρουμε στον R6 το byte της διεύθυνσης 
μνήμης όπου δείχνει ο R0
LDRB R7, [R0,#1] @Μεταφέρουμε στον R7 το byte της επόμενης 
διεύθυνσης μνήμης απ’όπου δείχνει ο R0
LDRB R8, [R0,#2] @Μεταφέρουμε στον R8 το byte της μεθεπόμενης 
διεύθυνσης μνήμης απ’όπου δείχνει ο R0
LDRB R9, [R1,#0] @Μεταφέρουμε στον R9 το byte της διεύθυνσης 
μνήμης όπου δείχνει ο R1
LDRB R10, [R1,#1] @Μεταφέρουμε στον R10 το byte της επόμενης 
διεύθυνσης μνήμης απ’όπου δείχνει ο R1
LDRB R11, [R1,#2] @Μεταφέρουμε στον R11 το byte της μεθεπόμενης 
διεύθυνσης μνήμης απ’όπου δείχνει ο R1
MUL R6,R9,R6 @Πολλαπλασιάζουμε τα bytes των διευθύνσεων μνήμης 
όπου δείχνουν οι R6, R9 (ai, z0) και αποθηκεύουμε το αποτέλεσμα 
στον R6
MUL R7,R10,R7 @Πολλαπλασιάζουμε τα bytes των διευθύνσεων μνήμης 
όπου δείχνουν οι R7, R10 (bi, z1) και αποθηκεύουμε το αποτέλεσμα 
στον R7
MUL R8,R11,R8 @Πολλαπλασιάζουμε τα bytes των διευθύνσεων μνήμης 
όπου δείχνουν οι R8, R11 (ci, z2) και αποθηκεύουμε το αποτέλεσμα 
στον R8
ADD R6,R7,R6 @Αθροίζουμε στην ουσία το ai*z0 με το bi*z1 και 
αποθηκεύουμε το αποτέλεσμα στον R6
SUB R6,R6,R8 @Αφαιρούμε στην ουσία από το bi*z1 το ci*z2 και 
αποθηκεύουμε το αποτέλεσμα στον R6
MUL R0,R5,R6 @Πολλαπλασιάζουμε το 5 που βρίσκεται στον 
καταχωρητή R5 με την παράσταση ai*z0 + bi*z1 - ci*z2 που βρίσκεται 
στον καταχωρητή R6 και αποθηκεύουμε το αποτέλεσμα στον R0
MOV R0,R0,LSR #6 @Κάνουμε δεξιά ολίσθηση του περιεχομένου που 
βρίσκεται στον R0 κατά 6 θέσεις για να διαιρέσουμε όλη τη 
παράσταση με το 64(26)
STRB R0, [R2,R3] @Φορτώνουμε στον R0 το byte της διεύθυνσης 
μνήμης όπου δείχνει ο R2
ADD R4,R4,#3 @Αυξάνουμε το περιεχόμενο του R4 κατά 3 
ADD R3,R3,#1 @Αυξάνουμε το περιεχόμενο του R3 κατά 1
LDMIA R13!,{R1-R6}
MOV PC,LR
.data
Values:
.byte 0x02, 0x03, 0x04
.byte 0x10, 0x05, 0x06
.byte 0x0B, 0x02, 0x0D
.byte 0x01, 0x0C, 0x08
Const:
.byte 0x04, 0x07, 0x05
Result:
.byte 0,0,0,0
